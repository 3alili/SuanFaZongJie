### 字符串
#####字符串就是字符数组
在java中字符串是常量不能直接操作，要用toCharArray,StringBuffer(多线程，复杂，性能差),StringBuilder（单线程，简单，性能好）来进行字符串操作。

### 1.双指针
移除元素，空格，反转字符串都可以使用双指针，降低复杂度。
**对于数组的填充问题，可以先扩充数组大小，然后反向填充。** 对原来的数组进行操作降低了空间复杂度，从后向前操作又可以确保数组在填充过程中不用每次都移动后面的元素，降低了时间复杂度。

对于java而言字符串是常量不能当作数组直接操作，所以字符串的填充问题一般是新建StringBuilder，然后填充再转化为字符串。如：字符串替换空格（卡码网）

### 2.反转字符串
双指针一头一尾，交换然后各自向中间前进。

如：反转字符串Ⅱ  先算要反转的区间，min(r=i+k—1,n-1)，然后再将i右移2k个单位。

如：反转字符串里的单词 先用双指针去除头尾的空格，然后反转字符串，再反转每个单词，同时对于单词间的多余空格删除。

### 3.KMP算法
**KMP算法核心思想就是用前缀表来简化匹配过程**，主要用于判断一个字符串中是否含有另一个子串。

KMP算法相比嵌套for循环优势体现在两个方面：
1.利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。
2.原串指针不会进行回溯，因为随着匹配过程的进行，原串指针的不断右移，我们本质上是在不断地在否决一些「不可能」的方案。

**核心：前缀表**
对于匹配串，每个下标对应的next数组的值就是以该位置为结尾的字符串中最长相同前后缀的长度，也就是如果在这个位置匹配失败，指针要跳转到的元素的下标（如果整体+或—1那就不一样了，但思想是一样的）。

**为什么能简化匹配呢？** 
因为匹配如果失败，根据前缀表跳转可以到其他与当前匹配过程中已经匹配成功的子串的位置继续匹配。也就是说根据前缀表，可以快速排查所有当前位置是否能与匹配串对应位置相符的情况。用前缀后缀创建前缀表，根据前缀表来一步步否决不可能的方案，使原串指针可以不回溯，降低复杂度，加速匹配。

**构建next数组**
一般情况：j=0，i=1（也可以整体+1，j=0，i=2，代码数值要稍微改动），next[o] = 0。

p[i] == p[j]:两个指针同时右移，next[i] = j+1,也就是i位置为结尾的字符串中最长前后缀为j+1。一直循环进行。

p[i] != p[j]:将j指向前一位置的next数组指向的值，直到匹配成功或者j=0也就是从头开始。j到0还不匹配意味着i这个位置没有相同的前缀能匹配它，所以i右移一位。**j指向前一位置的next数组指向的值**，这一步骤就是前缀表构造的关键，也就是简化匹配的关键，kmp算法的核心思想。

**匹配字符串**
i指向原串，j指向匹配串，根据next数组，如果不匹配且j>0，j就根据next数组跳转到next[j]位置，简化了匹配过程。如果匹配则j右移一位，j到达匹配串的最后一个字符且匹配完成时就代表匹配成功，返回答案。
