### 动态规划五部曲
1.确定dp数组以及对应下标的含义
2.确定递推公式
3.初始化dp数组
4.确定dp顺序
5.举例推导dp数组

70.爬楼梯 
dp[i]代表到达第i节台阶的方法数量。从这个角度看dp[0]就无关紧要了，初始化dp[1]和dp[2]就行了。
dp[i]取决于到达前两节台阶的方法数量即dp[i-1],dp[i-2]。

746.使用最小花费爬楼梯
dp[i]代表到达第i节台阶需要的最小费用，cost[i]代表从第i节台阶向上爬需要支付的费用，顶层台阶是不需要费用的，因为不需要再向上爬，所以顶层台阶的下标是cost最后一个下标再+1,也就是cost.length。**所以初始化dp时是int[cost.length+1],这样才能表示顶部位置的下标。**

62.不同路径
1.dp[i][j]代表到达该位置的路径数。
2.可以到达该位置的只有上边一格和左边一格，dp[i][j]= dp[i-1][j] + dp[i][j-1]。
3.**棋盘第一列和第一行都是1**
63.不同路径Ⅱ 
由于有障碍物，所以初始化时有障碍物**该位置及之后保持为0**。遍历的时候如果该位置有障碍物就跳过。

343.整数拆分
1.dp[i]代表i拆分后最大乘积
2.dp[i]有两种情况，一种是拆成2个数相乘dp[i] = j * i-j，另一种是拆成多个数dp[i] = j * dp[i-j],取最大值。
3.dp[2] = 1。
4.第一层for循环遍历i，第二层遍历j，dp[i] = Math.max( dp[i]  , Math.max( j *dp[i-j] , (j * i-j) ) )。**内层max比较拆成2个数或者多个数哪个更大，外层max比较当前和之前记录的哪个大，其实括号怎么扩都行，只要找出这三者的最大值就行。**

96.不同的二叉搜索树
1.dp[i]代表i个节点能组成的二叉搜索树数量。
2.从1到i分别为根节点能组成的二叉搜索树数量相加，**又因为不同元素间相对顺序是固定的，所以控制左右子树的数量，就是改变根节点的值。**
3.dp[1] = 1,dp[2] = 2。
4.第一层for循环遍历i，第二层循环控制左右子树的数量,dp[i] += dp[j] + dp[i-j-1]。

### 01背包问题
**二维数组：**
dp[i][j]代表容量为j的背包装0~i的东西能装的最大价值。
遍历顺序是从二维数组中该位置的上方和左上方到当前位置。所以无论先遍历物品还是背包容量都可以。
初始化一般第一列为0，第一行容量大于物品重量的位置为value[i]。

**一维数组：**
dp[i]代表容量为i的背包能装的最大价值。
一般初始化为0。**首先需要对背包容量进行从后往前的遍历**，这样它左边的值就等于其左上方的值，自身的值等于上方的值，也就是说没有用当前物品遍历过，保证每个物品只被放一次，一维数组是用覆盖来更新的。**循环顺序必须外侧物品，内层背包容量，保证在遍历该位置的时候其上方和左上方的值被覆盖过**，因为其实逻辑还是二维数组，只不过简化成了一维数组，当前位置依然取决于其上方和左上方的值，如果循环顺序改变，就是背包一次只能放一个物品。

416.分割等和子集
dp[i]就是容量为i的背包能装下的最大元素和。因为要分割成两个子集，所以i取元素总和的一半，如果dp[i]==i,代表正好有子集的和等于总和的一半。

1049.最后一块石头的重量
也是一样的思路，因为要使两堆石头重量相差最小，所以求dp[i]，i为总和的一半。最后sum-2*dp[i]，就是剩下的石头。

494.目标和
1.dp[i]代表和为i的组合数量
2.递推公式：dp[i] += dp[i-nums[j]]
3.初始化：dp[i]是从dp[0]推出来的，所以dp[0] == 1。**递推公式不一样，初始化也不同，要先确定递推公式，这是装满背包的组合数的递推公式。**
4.遍历顺序：先循环数组（物品），再循环容量（背包），一维数组：倒过来遍历。

474.一和零
1.dp[i][j]代表容量为i个0，j个1的背包能装入子集的最大数量,**容量有两个衡量标准所以要二维数组，但这题依然是个01背包，因为一个子集只能放一次**
2.递推公式：dp[i][j] = dp[i-zeroNum][j-oneNum]+1
3.初始化为0 就行，但要记录当前遍历的字符串中1的数量，0的数量，这相当于物品的重量。
4.遍历顺序：外层物品，内层背包，从后往前遍历。

### 完全背包问题
与01背包的区别在于，**遍历顺序是从前往后，因为一个物品可以放多次，纯背包问题循环怎么嵌套都行。**

518.零钱兑换Ⅱ
这题和目标和有点像，都是**组合问题。在完全背包问题中，组合问题要先循环物品，再循环容量；排列问题要先循环容量，再循环物品。** 至于为什么我也说不清，但画图推一遍就能感觉出为什么。
所以这题和目标和就**相差在物品能不能重复放，也就是说遍历顺序要变成从前往后。** 其他都一样。

爬楼梯
排列问题，可重复放。

377.组合总和Ⅳ
完全背包，组合。

322.零钱兑换
完全背包，组合问题。**要注意该题求最小硬币数，所以初始化数组需要初始化为一个超出范围的较大数。**

279.完全平方数
完全背包，组合问题。和上一题一样初始化。

139.单词拆分
排列➕完全背包。我认为比较难的就是字符串的处理一直不太熟练，用hashset存储字典（物品），用substring找背包的空闲区间，判断能不能放下该物品。

### 多重背包问题
这种题目其实是01背包的变形，**因为比如一个物品有n件，可以把它看成是n个相同但独立的物品**，当做01背包处理。先循环物品，再循环背包（组合），从后往前遍历（01背包，不能重复放），**区别在于内层for循环中还要有一个for循环来遍历n个相同物品。**
<br>

### 打家劫舍
198.打家劫舍
基础问题，相邻不被偷就不报警，dp[i]由上一家和上上一家推导来。
dp初始化前两个元素就行。

213.打家劫舍Ⅱ
在环形中找一点切割，分两种情况：1.第一家不考虑 2.最后一家不考虑。这样就化解成了2种情况的打家劫舍基础问题。

337.打家劫舍Ⅲ
树形dp，相连节点不能一起偷，按照递归三部曲做。
1.**递归函数的参数**：当前节点。
**返回值**：一个一维数组，dp[0]代表当前节点不偷获得的最大金额，dp[1]代表当前节点偷获得的最大金额。
2.**终止条件**：空节点，返回元素为0的数组
3.**遍历顺序**：后序遍历，因为需要通过子节点的返回值来判断当前节点怎么操作,left[]是左子树能偷的最大金额,right[]是右子树能偷的最大金额。
**单层递归逻辑**：该节点不偷，**左右节点能考虑，但不是一定会偷**,dp[0] = Math.max(left[0],left[1]) + Math.max(right[0],right[1])。该节点偷，左右节点就一定不偷，dp[1] = left[0] + right[0] + node.val。
<br>

### 买卖股票
121.买卖股票
dp[i][0]代表第i天不持有股票拥有的最大金额
dp[i][1]代表第i天持有股票拥有的最大金额

初始化dp[0][0],dp[0][1]

dp[i][0] = 前一天就不持有和今天卖掉中的最大值
dp[i][1] = 前一天持有和今天买入后拥有金额的最大值

122.买卖股票的最佳时机Ⅱ
可以买卖多次，递推公式和上一题不一样。

123.买卖股票的最佳时机Ⅲ
最多只能交易两次，一共有5个状态：0.没有操作，1.第一次买入，2.第一次卖出，3.第二次买入，4.第二次卖出。当前的现金取决于上一天，上一次或同一次交易的值。

188.买卖股票的最佳时机Ⅳ
交易次数为k，状态有2*k+1个，偶数代表卖出状态，奇数代表买入状态。
根据题意，**某次交易一定是先买入再卖出的，所以某次交易的持有状态应该由前一天的持有和前一天的未操作状态推导出来。前一天的卖出状态意味着上一次交易已经结束了，当前是接下来的一次交易。**

309.最佳买卖股票时机含冷冻期
这题有4种状态：0.今天买或前几天买（持有状态），1.今天卖（未持有状态），2.前几天卖（未持有状态），3.昨天卖（冷冻状态）。
因为卖出后有冷冻期，所以未持有状态分为1和2，状态2由前一天的3状态（冷冻期）和2状态（未持有）推导。状态1由前一天的状态0推导。分开方便理解。
状态0由前一天的状态3和状态0推导。
状态3由前一天的状态1推导。

714.买卖股票含手续费
和股票Ⅱ不同之处是每次交易有手续费，递推公式调整一下，初始化调整一下，其他都一样。

**动规五部曲每一步都很重要，dp的含义要定义清楚，推导公式才能不出错，初始化，遍历顺序都会受前面的步骤影响。**
**一切的开始是定义dp数组，然后按照dp数组的含义去确定推导公式，再是初始化，遍历顺序，后面的步骤都是从dp数组的含义出发，然后一道题目就自然而然完成了。我就觉得很神奇，仿佛这道题是在自己完成自己。**
我之前在哪里看到过一个说法：你想变成什么样的人，就想象这样的人会怎么做，然后这样做，慢慢地就能变成你想象的那个人。想变成什么样的人就是在定义dp数组，只要定义的足够精准，正确，后面的步骤就很好展开。或许这就是吾性自足，心即理的表现？阳明先生常说：事上磨练。此言非虚。