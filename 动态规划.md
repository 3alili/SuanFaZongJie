### 动态规划五部曲
1.确定dp数组以及对应下标的含义
2.确定递推公式
3.初始化dp数组
4.确定dp顺序
5.举例推导dp数组

70.爬楼梯 
dp[i]代表到达第i节台阶的方法数量。从这个角度看dp[0]就无关紧要了，初始化dp[1]和dp[2]就行了。
dp[i]取决于到达前两节台阶的方法数量即dp[i-1],dp[i-2]。

746.使用最小花费爬楼梯
dp[i]代表到达第i节台阶需要的最小费用，cost[i]代表从第i节台阶向上爬需要支付的费用，顶层台阶是不需要费用的，因为不需要再向上爬，所以顶层台阶的下标是cost最后一个下标再+1,也就是cost.length。**所以初始化dp时是int[cost.length+1],这样才能表示顶部位置的下标。**

62.不同路径
1.dp[i][j]代表到达该位置的路径数。
2.可以到达该位置的只有上边一格和左边一格，dp[i][j]= dp[i-1][j] + dp[i][j-1]。
3.**棋盘第一列和第一行都是1**
63.不同路径Ⅱ 
由于有障碍物，所以初始化时有障碍物**该位置及之后保持为0**。遍历的时候如果该位置有障碍物就跳过。

343.整数拆分
1.dp[i]代表i拆分后最大乘积
2.dp[i]有两种情况，一种是拆成2个数相乘dp[i] = j * i-j，另一种是拆成多个数dp[i] = j * dp[i-j],取最大值。
3.dp[2] = 1。
4.第一层for循环遍历i，第二层遍历j，dp[i] = Math.max( dp[i]  , Math.max( j *dp[i-j] , (j * i-j) ) )。**内层max比较拆成2个数或者多个数哪个更大，外层max比较当前和之前记录的哪个大，其实括号怎么扩都行，只要找出这三者的最大值就行。**

96.不同的二叉搜索树
1.dp[i]代表i个节点能组成的二叉搜索树数量。
2.从1到i分别为根节点能组成的二叉搜索树数量相加，**又因为不同元素间相对顺序是固定的，所以控制左右子树的数量，就是改变根节点的值。**
3.dp[1] = 1,dp[2] = 2。
4.第一层for循环遍历i，第二层循环控制左右子树的数量,dp[i] += dp[j] + dp[i-j-1]。 