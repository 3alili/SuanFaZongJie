### 动态规划五部曲
1.确定dp数组以及对应下标的含义
2.确定递推公式
3.初始化dp数组
4.确定dp顺序
5.举例推导dp数组

70.爬楼梯 
dp[i]代表到达第i节台阶的方法数量。从这个角度看dp[0]就无关紧要了，初始化dp[1]和dp[2]就行了。
dp[i]取决于到达前两节台阶的方法数量即dp[i-1],dp[i-2]。

746.使用最小花费爬楼梯
dp[i]代表到达第i节台阶需要的最小费用，cost[i]代表从第i节台阶向上爬需要支付的费用，顶层台阶是不需要费用的，因为不需要再向上爬，所以顶层台阶的下标是cost最后一个下标再+1,也就是cost.length。**所以初始化dp时是int[cost.length+1],这样才能表示顶部位置的下标。**

62.不同路径
1.dp[i][j]代表到达该位置的路径数。
2.可以到达该位置的只有上边一格和左边一格，dp[i][j]= dp[i-1][j] + dp[i][j-1]。
3.**棋盘第一列和第一行都是1**
63.不同路径Ⅱ 
由于有障碍物，所以初始化时有障碍物**该位置及之后保持为0**。遍历的时候如果该位置有障碍物就跳过。

343.整数拆分
1.dp[i]代表i拆分后最大乘积
2.dp[i]有两种情况，一种是拆成2个数相乘dp[i] = j * i-j，另一种是拆成多个数dp[i] = j * dp[i-j],取最大值。
3.dp[2] = 1。
4.第一层for循环遍历i，第二层遍历j，dp[i] = Math.max( dp[i]  , Math.max( j *dp[i-j] , (j * i-j) ) )。**内层max比较拆成2个数或者多个数哪个更大，外层max比较当前和之前记录的哪个大，其实括号怎么扩都行，只要找出这三者的最大值就行。**

96.不同的二叉搜索树
1.dp[i]代表i个节点能组成的二叉搜索树数量。
2.从1到i分别为根节点能组成的二叉搜索树数量相加，**又因为不同元素间相对顺序是固定的，所以控制左右子树的数量，就是改变根节点的值。**
3.dp[1] = 1,dp[2] = 2。
4.第一层for循环遍历i，第二层循环控制左右子树的数量,dp[i] += dp[j] + dp[i-j-1]。

### 01背包问题
**二维数组：**
dp[i][j]代表容量为j的背包装0~i的东西能装的最大价值。
遍历顺序是从二维数组中该位置的上方和左上方到当前位置。所以无论先遍历物品还是背包容量都可以。
初始化一般第一列为0，第一行容量大于物品重量的位置为value[i]。

**一维数组：**
dp[i]代表容量为i的背包能装的最大价值。
初始化为0。**遍历顺序必须外侧物品，内层背包容量**，因为其实逻辑还是二维数组，只不过简化成了一维数组，当前位置依然取决于其上方和左上方的值。**所以还需要对背包容量进行后序遍历**，这样它左边的值就等于其左上方的值，自身的值等于上方的值，一维数组是用覆盖来更新的。

416.分割等和子集
dp[i]就是容量为i的背包能装下的最大元素和。因为要分割成两个子集，所以i取元素总和的一半，如果dp[i]==i,代表正好有子集的和等于总和的一半。

1049.最后一块石头的重量
也是一样的思路，因为要使两堆石头重量相差最小，所以求dp[i]，i为总和的一半。最后sum-2*dp[i]，就是剩下的石头。