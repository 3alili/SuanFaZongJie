###栈与队列
java中一般使用deque双端队列来实现栈和队列。
deque有数组和链表两种实现。

###1.栈，队列实现
**栈实现队列**，用两个栈:in,out。in用来保存输入元素，out用来保存输出元素。
输入时，将out中的元素全部入in栈，然后再输入元素。
输出时，将in中的元素全部入out栈，然后再输出元素。
**deque只用一端输入输出就能实现栈**

**队列实现栈**，用一个队列。
输入就正常输入。
输出时将除最后一个元素外的所有元素排到队列末尾，然后输出一次，再循环操作。
**deque一端入一端出即实现队列**

###2.栈的题目
####1.递归的实现
**递归的实现是栈：每一次递归调用都会把函数的局部变量,参数值和返回地址等压入调用栈中。**

####2.括号匹配
有三种匹配情况：
一.左括号多余
二.右括号多余
三.正好匹配
对于左括号，相应入栈对应的右括号，然后对于右括号只需判断当前右括号是否与栈顶的括号相同。如果相同则弹出栈顶括号并判断下一个右括号，最后如果栈为空则匹配成功。

####3.字符串去重
每次入栈时判断当前字符与栈顶字符是否相同，如果相同弹出栈顶字符并进行下一个字符的判断。

####4.逆波兰表达式
对于+-*/四种字符，弹出栈顶的两个数字进行相应的计算，将结果重新入栈。
**减法运算时要注意先弹出的数字要加个负号，然后再和后弹出的数字相加。**
**除法运算时要注意定义两个int变量存储弹出的两个元素，然后进行除法运算，再入栈。**

###3.队列的题目
####1.滑动窗口最大值
核心思路之一是使用单调队列，队列就是窗口。
**如何维护单调队列**：对于入队元素，将其与队尾元素比较，若入队元素较大，即入队会破坏单调递减则弹出队尾元素，循环进行直到可以入队或队列为空。

这样做的好处：
1.不用维护所有元素，不是优先队列，复杂度低。
2.因为保证了单调性，所以该窗口任何时刻最大值都在队头，即出队口。

每次移动完窗口判断队头元素是否还在窗口内，如果不在则弹出，如果在则peekFirst并保存在答案中。

####2.求前k个高频元素
因为要求前k个元素，而且k不确定，所以核心思路是使用优先级队列。
优先级队列就是堆，堆就是完全二叉树，左结点小于右结点，即有序。
优先级队列使用大顶堆或小顶堆进行排序。大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）。

使用PriorityQueue实现堆。
**为什么使用小顶堆：小顶堆即队列头是最小元素，如果有更大的元素入队，就直接弹出头部的最小元素即可。**
处理完所有元素，从队列尾输出k个元素即为前k个高频元素。

