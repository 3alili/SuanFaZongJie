### 回溯
**回溯是递归的副产物，只要有递归就有回溯**
用递归控制for循环嵌套的数量。
回溯可以抽象成树形结构:**for循环横向遍历，递归纵向遍历，回溯调整结果集**

### 组合
剪枝：
77.组合 for循环起始位置之后的元素个数如果不够题目要求，直接略过。
216.组合综合 已选元素总和如果大于目标总和，略过。

**组合问题什么时候需要startIndex：一个集合求组合。**
如果多个集合取组合，各个集合互不影响，就不用。
**元素不能重复使用就在递归时把i+1传入,能重复就传入i。**

40.组合总和Ⅱ 
关键在于如何去重，题目要求数组中每个元素只能用一次，但数组中又有重复元素，解集还不能包含重复组合。所以**先给数组排序**，然后在回溯的单层循环逻辑中(**同一树层**) 先判断当前元素是不是**第一次遇到**，如果是就循环，如果不是就continue。因为在当前树层中第一次遇到该元素的时候，已经把它开头的所有组合遍历过了，所以再次遇到就直接略过，可以确保没有重复组合。
判断逻辑(i > startIndex && candidates[i] == candidates[i-1]),为真则不是第一次遇到。

### 切割
其实和组合问题思路是差不多的，循环逻辑是：先判断是否符合条件再用substring切割字符串(startIndex，i)然后添加到path中。接着循环下一个位置的字符。
**substring是左闭右开**

131.分割回文串

93.复原ip地址 
终止条件：加了3个分隔的点，同时最后一段字符串符合条件。
单层循环逻辑：新建stringbuilder方便操作，循环字符串，符合条件就在后一个位置加入'.',循环后一个字符。
判断字符串是否符合条件中，字符要-'0'才能转化为数字

### 子集
**组合是收集叶子结点。子集是收集每个所有结点**，差别在于每次回溯首先把当前的path添加到res中，因为不需要找到叶子结点再添加。
78.子集:这是一道回溯的模板题目，startIndex是起点，i是终点，每次递归要传入i+1作为startIndex。
90.子集Ⅱ:关键区别在去重，一般是用一个**数组used[]来标记每个元素在当前树枝中有没有使用过**，false就是没使用过，如果当前节点还与前一个节点相等，**当前节点与前一个节点在同一树层**，重复了，要跳过。true就是在这个树枝上用过，即使当前节点与前一个节点相等，也只是同一集合中的重复元素，在树枝中可以重复。
**used[i-1] = true代表两节点是同一树枝，可以重复使用。**
**used[i-1] = false代表两节点是同一树层，不能重复使用。**


这道题因为是**求子集，也就是组合**，每次for循环不用从头开始，可以用**startIndex**来去重，不回头，遇到和前一个重复的就跳过。求排列要从头开始，所以只能用used数组来记录。

### 递增子序列
该题思路大致和子集差不多，但**不能对数组进行排序。所以不能用startIndex实现去重**，单层循环逻辑中，去重需要引入一个HashSet判断同层有没有用过该元素，还有一个条件是保持递增。

### 全排列
排列由于有顺序要求，每次遍历需要从头开始，不能用startIndex**树层与树枝去重**，需要定义used数组来记录元素是否有被使用过,在循环开始处进行树层去重。处理当前节点，进入递归前进行树枝去重。
46.全排列：这道题数组中没有重复元素，所以去重逻辑比较简单，只需要树枝去重即used[i] == false就可以进行循环逻辑。
47.全排列Ⅱ：这道题数组中有重复元素，去重时需要注意树层去重，**排序后**，当该节点与前一个节点相等同时**used[i-1] == false**，意味着重复了，需要跳过。树枝间去重和上一题一样，只要**当前节点没用过**就可以继续。

### 棋盘问题
n皇后:棋盘宽度（树层的宽度）就是for循环的长度，递归的次数就是棋盘的长度（树的高度），**因为这道题一行只放一个棋子，所以递归的次数也就代表了行数**。
解数独：相比n皇后每行只放一个棋子，这道题一行要放n个。所以需要两个for循环，外层for循环控制行，内层for循环控制列，遍历每个位置。由于数字也不确定，所以还需要第三个for循环遍历1到9在该位置是否符合。树层宽度是9，**递归的次数就是树的高度也是空位的个数**。
**for循环用来找处理的位置，里面的递归函数则是在此基础上找下一个要处理的位置。**