### 回溯
**回溯是递归的副产物，只要有递归就有回溯**
用递归控制for循环嵌套的数量。
回溯可以抽象成树形结构:**for循环横向遍历，递归纵向遍历，回溯调整结果集**

### 组合
剪枝：
77.组合 for循环起始位置之后的元素个数如果不够题目要求，直接略过。
216.组合综合 已选元素总和如果大于目标总和，略过。

**组合问题什么时候需要startIndex：一个集合求组合。**
如果多个集合取组合，各个集合互不影响，就不用。

40.组合总和Ⅱ 
关键在于如何去重，题目要求数组中每个元素只能用一次，但数组中又有重复元素，解集还不能包含重复组合。所以**先给数组排序**，然后在回溯的单层循环逻辑中先判断当前元素是不是**第一次遇到**，如果是就循环，如果不是就continue。因为第一次遇到该元素的时候，已经把它开头的所有组合遍历过了，所以再次遇到就直接略过，可以确保没有重复组合。
判断逻辑(i > startIndex && candidates[i] == candidates[i-1]),为真则不是第一次遇到。

### 切割
其实和组合问题思路是差不多的，循环逻辑是：先判断是否符合条件再用substring切割字符串(startIndex，i)然后添加到path中。接着循环下一个位置的字符。
**substring是左闭右开**

131.分割回文串

93.复原ip地址 
终止条件：加了3个分隔的点，同时最后一段字符串符合条件。
单层循环逻辑：新建stringbuilder方便操作，循环字符串，符合条件就在后一个位置加入'.',循环后一个字符。
判断字符串是否符合条件中，字符要-'0'才能转化为数字

### 子集
**组合是收集叶子结点。子集是收集每个所有结点**，差别在于每次回溯首先把当前的path添加到res中，因为不需要找到叶子结点再添加。
78.子集:这是一道回溯的模板题目，startIndex是起点，i是终点，每次递归要传入i+1作为startIndex。
90.子集Ⅱ:关键区别在去重，一般是用一个**数组used[]来标记每个元素在当前树枝中有没有使用过**，false就是没使用过，如果当前节点还与前一个节点相等，那就是当前树层遍历中，已经用过前一个节点查找过了，也就是说重复了，要跳过。true就是在这个树枝上用过，即使当前节点与前一个节点相等，也只是同一集合中的重复元素，在树枝中可以重复。
**目前理解就是两个节点相等，前一个节点true代表当前节点是可以接在前一个节点下面的，是重复的元素。false代表当前节点是和前一个节点同一层的，同一层是不能重复的。**

这道题因为是**求子集，也就是组合**，每次for循环不用从头开始，可以用**startIndex**来去重，不回头，遇到和前一个重复的就跳过。求排列要从头开始，所以只能用used数组来记录。

### 递增子序列
该题思路大致和子集差不多，但**不能对数组进行排序。所以不能用startIndex实现去重**，单层循环逻辑中，去重需要引入一个HashSet判断同层有没有用过该元素，还有一个条件是保持递增。

### 全排列
排列由于有顺序要求，每次遍历需要从头开始，不能用startIndex去重，需要定义used数组来记录元素是否有被使用过。
46.全排列：这道题数组中没有重复元素，所以去重逻辑比较简单，只需要树枝去重即used[i] == false就可以进行循环逻辑。
47.全排列Ⅱ：这道题数组中有重复元素，去重时需要注意树层去重，**排序后**，当该节点与前一个节点相等同时**used[i-1] == false**，意味着重复了，需要跳过。树枝间去重和上一题一样，只要**当前节点没用过**就可以继续。