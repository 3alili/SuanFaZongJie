### 贪心算法
**贪心的本质是选择每一阶段的局部最优，从而达到全局最优。**
感觉局部最优可以推出全局最优，然后想不到反例，就试试贪心算法。

455.分发饼干 局部最优：大饼干先满足大胃口（胃口太大就减小，尽足饼干），或者先用小饼干满足小胃口（饼干太小就增大，尽足胃口）。

376.摆动序列 局部最优：每个单调坡上只有两端的2个节点，中间的略过。

53.最大子数组 局部最优：加上当前的数，累计和小于0，就舍弃，因为这块小于0对于后面的全局最大起副作用。

55.跳跃游戏 局部最优：在当前元素的覆盖范围内找能跳得最远的那个位置。 判断能否包含终点

45.跳跃游戏Ⅱ 局部最优：与上一题相同。 只是在每次超出当前跳跃的覆盖范围时需要将跳跃次数+1，**用temp记录可以跳得最远的范围，因为要记录跳跃的次数**。上一题不需要记录跳跃次数，所以直接将cover更新为最大值就行。

1005.k次取反 局部最优：**将尽可能多的绝对值最大的负数取反，绝对值最小的正数取反。** 先排序，然后对开头的负数进行取反，如果k还有剩余，意味着数组全为非负数。再排序，数组开头的数字就是最小正数，如果k为奇数，对其取反，为偶数则不动。

134.加油站  局部最优:剩余的汽油足够跑到下一站。 全局最优：汽油总和大于消耗总和。 **如果当前剩余汽油跑不到下一站，说明当前起点到当前位置之间的任何位置都不能作为起点**，调整起点为i+1，剩余汽油清零。如果遍历完汽油总和大于消耗总和，返回起点。

**两个维度的问题要分开考虑**
135.分发糖果  局部最优：1.比左边高糖果要比左边多 2.比右边高糖果要比右边多。 有左右两个维度，要分开考虑，先考虑比左边高，再考虑比右边高。
406.根据身高重建队列  局部最优：1.按身高降序排列 2.按k插入，重新排序。  先按照身高进行降序排列，用**Arrays.sort(数组，(a,b))->{排序逻辑}，lambda表达式前减后升序，后减前降序**。再按照k进行插入对应的下标，因为是升序队列，插入下标为k的位置后队列就排序完成了。